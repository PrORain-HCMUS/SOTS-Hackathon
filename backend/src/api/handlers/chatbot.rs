use axum::{
    extract::{Path, State},
    Extension, Json,
};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use uuid::Uuid;
use validator::Validate;

use crate::api::handlers::ApiResponse;
use crate::api::middleware::auth::Claims;
use crate::api::routes::AppState;
use crate::domain::{DomainError, Todo, TodoPriority, TodoSource};

#[derive(Debug, Deserialize, Validate)]
pub struct ChatMessage {
    #[validate(length(min = 1, message = "Message is required"))]
    pub message: String,
    pub context: Option<ChatContext>,
}

#[derive(Debug, Deserialize)]
pub struct ChatContext {
    pub farm_id: Option<Uuid>,
    pub include_alerts: bool,
    pub include_predictions: bool,
}

#[derive(Debug, Serialize)]
pub struct ChatResponse {
    pub message: String,
    pub actions: Vec<ChatAction>,
    pub data: Option<serde_json::Value>,
}

#[derive(Debug, Serialize)]
pub struct ChatAction {
    pub action_type: String,
    pub description: String,
    pub completed: bool,
}

#[derive(Debug, Deserialize, Validate)]
pub struct CreateTodoRequest {
    #[validate(length(min = 1, message = "Title is required"))]
    pub title: String,
    pub description: Option<String>,
    pub farm_id: Option<Uuid>,
    pub priority: Option<String>,
    pub due_date: Option<DateTime<Utc>>,
}

#[derive(Debug, Deserialize)]
pub struct UpdateTodoRequest {
    pub title: Option<String>,
    pub description: Option<String>,
    pub priority: Option<String>,
    pub due_date: Option<DateTime<Utc>>,
}

#[derive(Debug, Serialize)]
pub struct TodoResponse {
    pub id: Uuid,
    pub title: String,
    pub description: Option<String>,
    pub farm_id: Option<Uuid>,
    pub priority: String,
    pub due_date: Option<DateTime<Utc>>,
    pub completed: bool,
    pub source: String,
    pub created_at: DateTime<Utc>,
}

impl From<Todo> for TodoResponse {
    fn from(todo: Todo) -> Self {
        Self {
            id: todo.id,
            title: todo.title,
            description: todo.description,
            farm_id: todo.farm_id,
            priority: match todo.priority {
                TodoPriority::Low => "low".to_string(),
                TodoPriority::Medium => "medium".to_string(),
                TodoPriority::High => "high".to_string(),
                TodoPriority::Urgent => "urgent".to_string(),
            },
            due_date: todo.due_date,
            completed: todo.completed,
            source: match todo.source {
                TodoSource::Manual => "manual".to_string(),
                TodoSource::AutoGenerated => "auto_generated".to_string(),
                TodoSource::Chatbot => "chatbot".to_string(),
            },
            created_at: todo.created_at,
        }
    }
}

#[derive(Debug, Deserialize, Validate)]
pub struct GenerateReportRequest {
    pub farm_id: Uuid,
    pub start_date: Option<DateTime<Utc>>,
    pub end_date: Option<DateTime<Utc>>,
    pub report_type: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct ReportResponse {
    pub id: Uuid,
    pub title: String,
    pub content: String,
    pub summary: String,
    pub generated_at: DateTime<Utc>,
}

pub async fn send_message(
    State(_state): State<Arc<AppState>>,
    Extension(claims): Extension<Claims>,
    Json(payload): Json<ChatMessage>,
) -> Result<Json<ApiResponse<ChatResponse>>, DomainError> {
    if let Err(e) = payload.validate() {
        return Err(DomainError::validation(e.to_string()));
    }

    tracing::info!(
        "Chat message from user {}: {}",
        claims.sub,
        payload.message
    );

    let response = process_chat_message(&payload.message, &claims, payload.context.as_ref());

    Ok(Json(ApiResponse::success(response)))
}

fn process_chat_message(
    message: &str,
    _claims: &Claims,
    _context: Option<&ChatContext>,
) -> ChatResponse {
    let message_lower = message.to_lowercase();

    if message_lower.contains("salinity") || message_lower.contains("mặn") {
        return ChatResponse {
            message: "Dựa trên dữ liệu vệ tinh mới nhất, độ mặn trong khu vực của bạn đang ở mức an toàn. Tuy nhiên, hệ thống đang theo dõi một xu hướng tăng nhẹ trong 5 ngày qua.".to_string(),
            actions: vec![
                ChatAction {
                    action_type: "get_salinity_status".to_string(),
                    description: "Đã truy vấn dữ liệu độ mặn".to_string(),
                    completed: true,
                }
            ],
            data: Some(serde_json::json!({
                "current_ndsi": 0.15,
                "trend": "slightly_increasing",
                "risk_level": "low"
            })),
        };
    }

    if message_lower.contains("alert") || message_lower.contains("cảnh báo") {
        return ChatResponse {
            message: "Hiện tại không có cảnh báo nào đang hoạt động cho khu vực của bạn.".to_string(),
            actions: vec![
                ChatAction {
                    action_type: "check_alerts".to_string(),
                    description: "Đã kiểm tra cảnh báo".to_string(),
                    completed: true,
                }
            ],
            data: None,
        };
    }

    if message_lower.contains("todo") || message_lower.contains("việc") {
        return ChatResponse {
            message: "Bạn có thể tạo todo mới bằng cách sử dụng endpoint POST /api/v1/chatbot/todos".to_string(),
            actions: vec![],
            data: None,
        };
    }

    if message_lower.contains("report") || message_lower.contains("báo cáo") {
        return ChatResponse {
            message: "Tôi có thể tạo báo cáo cho bạn. Vui lòng cho biết khoảng thời gian bạn muốn báo cáo (ví dụ: tuần này, tháng này, hoặc từ ngày đến ngày).".to_string(),
            actions: vec![],
            data: None,
        };
    }

    ChatResponse {
        message: format!(
            "Xin chào! Tôi là trợ lý AI của Bio-Radar. Tôi có thể giúp bạn:\n\
            - Kiểm tra tình trạng độ mặn\n\
            - Xem các cảnh báo xâm nhập mặn\n\
            - Tạo và quản lý danh sách việc cần làm\n\
            - Tạo báo cáo tình hình đất đai\n\n\
            Bạn cần hỗ trợ gì?"
        ),
        actions: vec![],
        data: None,
    }
}

pub async fn list_todos(
    State(_state): State<Arc<AppState>>,
    Extension(claims): Extension<Claims>,
) -> Result<Json<ApiResponse<Vec<TodoResponse>>>, DomainError> {
    tracing::info!("Listing todos for user: {}", claims.sub);

    Ok(Json(ApiResponse::success(vec![])))
}

pub async fn create_todo(
    State(_state): State<Arc<AppState>>,
    Extension(claims): Extension<Claims>,
    Json(payload): Json<CreateTodoRequest>,
) -> Result<Json<ApiResponse<TodoResponse>>, DomainError> {
    if let Err(e) = payload.validate() {
        return Err(DomainError::validation(e.to_string()));
    }

    let now = Utc::now();
    let todo = Todo {
        id: Uuid::new_v4(),
        user_id: claims.sub,
        farm_id: payload.farm_id,
        title: payload.title,
        description: payload.description,
        priority: payload.priority.map(|p| match p.as_str() {
            "low" => TodoPriority::Low,
            "high" => TodoPriority::High,
            "urgent" => TodoPriority::Urgent,
            _ => TodoPriority::Medium,
        }).unwrap_or(TodoPriority::Medium),
        due_date: payload.due_date,
        completed: false,
        completed_at: None,
        created_at: now,
        source: TodoSource::Chatbot,
    };

    tracing::info!("Created todo {} for user: {}", todo.id, claims.sub);

    Ok(Json(ApiResponse::success(TodoResponse::from(todo))))
}

pub async fn update_todo(
    State(_state): State<Arc<AppState>>,
    Extension(claims): Extension<Claims>,
    Path(id): Path<Uuid>,
    Json(_payload): Json<UpdateTodoRequest>,
) -> Result<Json<ApiResponse<TodoResponse>>, DomainError> {
    tracing::info!("Updating todo {} for user: {}", id, claims.sub);

    Err(DomainError::not_found(format!("Todo {} not found", id)))
}

pub async fn complete_todo(
    State(_state): State<Arc<AppState>>,
    Extension(claims): Extension<Claims>,
    Path(id): Path<Uuid>,
) -> Result<Json<ApiResponse<()>>, DomainError> {
    tracing::info!("Completing todo {} for user: {}", id, claims.sub);

    Ok(Json(ApiResponse::success(())))
}

pub async fn generate_report(
    State(_state): State<Arc<AppState>>,
    Extension(claims): Extension<Claims>,
    Json(payload): Json<GenerateReportRequest>,
) -> Result<Json<ApiResponse<ReportResponse>>, DomainError> {
    tracing::info!(
        "Generating report for farm {} user: {}",
        payload.farm_id,
        claims.sub
    );

    let now = Utc::now();
    let start = payload.start_date.unwrap_or(now - chrono::Duration::days(30));
    let end = payload.end_date.unwrap_or(now);

    let report = ReportResponse {
        id: Uuid::new_v4(),
        title: format!("Báo cáo tình hình đất đai từ {} đến {}", 
            start.format("%d/%m/%Y"), 
            end.format("%d/%m/%Y")),
        content: "Nội dung báo cáo chi tiết sẽ được tạo dựa trên dữ liệu thực tế.".to_string(),
        summary: "Tóm tắt: Tình hình đất đai ổn định, không có dấu hiệu xâm nhập mặn nghiêm trọng.".to_string(),
        generated_at: now,
    };

    Ok(Json(ApiResponse::success(report)))
}
