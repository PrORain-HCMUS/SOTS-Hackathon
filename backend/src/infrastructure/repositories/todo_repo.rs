use async_trait::async_trait;
use chrono::{DateTime, Utc};
use sqlx::PgPool;
use uuid::Uuid;

use crate::domain::{
    repositories::TodoRepository, DomainError, DomainResult, Todo, TodoPriority, TodoSource,
};

pub struct PgTodoRepository {
    pool: PgPool,
}

impl PgTodoRepository {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }
}

#[derive(sqlx::FromRow)]
struct TodoRow {
    id: Uuid,
    user_id: Uuid,
    farm_id: Option<Uuid>,
    title: String,
    description: Option<String>,
    priority: String,
    due_date: Option<DateTime<Utc>>,
    completed: bool,
    completed_at: Option<DateTime<Utc>>,
    created_at: DateTime<Utc>,
    source: String,
}

impl From<TodoRow> for Todo {
    fn from(row: TodoRow) -> Self {
        Todo {
            id: row.id,
            user_id: row.user_id,
            farm_id: row.farm_id,
            title: row.title,
            description: row.description,
            priority: parse_priority(&row.priority),
            due_date: row.due_date,
            completed: row.completed,
            completed_at: row.completed_at,
            created_at: row.created_at,
            source: parse_source(&row.source),
        }
    }
}

fn parse_priority(s: &str) -> TodoPriority {
    match s {
        "low" => TodoPriority::Low,
        "medium" => TodoPriority::Medium,
        "high" => TodoPriority::High,
        "urgent" => TodoPriority::Urgent,
        _ => TodoPriority::Medium,
    }
}

fn priority_to_string(p: &TodoPriority) -> String {
    match p {
        TodoPriority::Low => "low".to_string(),
        TodoPriority::Medium => "medium".to_string(),
        TodoPriority::High => "high".to_string(),
        TodoPriority::Urgent => "urgent".to_string(),
    }
}

fn parse_source(s: &str) -> TodoSource {
    match s {
        "manual" => TodoSource::Manual,
        "auto_generated" => TodoSource::AutoGenerated,
        "chatbot" => TodoSource::Chatbot,
        _ => TodoSource::Manual,
    }
}

fn source_to_string(s: &TodoSource) -> String {
    match s {
        TodoSource::Manual => "manual".to_string(),
        TodoSource::AutoGenerated => "auto_generated".to_string(),
        TodoSource::Chatbot => "chatbot".to_string(),
    }
}

#[async_trait]
impl TodoRepository for PgTodoRepository {
    async fn find_by_id(&self, id: Uuid) -> DomainResult<Option<Todo>> {
        let row = sqlx::query_as::<_, TodoRow>(
            r#"
            SELECT id, user_id, farm_id, title, description, priority,
                   due_date, completed, completed_at, created_at, source
            FROM todos
            WHERE id = $1
            "#,
        )
        .bind(id)
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| DomainError::database(e.to_string()))?;

        Ok(row.map(Todo::from))
    }

    async fn find_by_user_id(&self, user_id: Uuid) -> DomainResult<Vec<Todo>> {
        let rows = sqlx::query_as::<_, TodoRow>(
            r#"
            SELECT id, user_id, farm_id, title, description, priority,
                   due_date, completed, completed_at, created_at, source
            FROM todos
            WHERE user_id = $1
            ORDER BY 
                CASE priority 
                    WHEN 'urgent' THEN 1 
                    WHEN 'high' THEN 2 
                    WHEN 'medium' THEN 3 
                    ELSE 4 
                END,
                due_date ASC NULLS LAST,
                created_at DESC
            "#,
        )
        .bind(user_id)
        .fetch_all(&self.pool)
        .await
        .map_err(|e| DomainError::database(e.to_string()))?;

        Ok(rows.into_iter().map(Todo::from).collect())
    }

    async fn find_pending_by_user(&self, user_id: Uuid) -> DomainResult<Vec<Todo>> {
        let rows = sqlx::query_as::<_, TodoRow>(
            r#"
            SELECT id, user_id, farm_id, title, description, priority,
                   due_date, completed, completed_at, created_at, source
            FROM todos
            WHERE user_id = $1 AND completed = false
            ORDER BY 
                CASE priority 
                    WHEN 'urgent' THEN 1 
                    WHEN 'high' THEN 2 
                    WHEN 'medium' THEN 3 
                    ELSE 4 
                END,
                due_date ASC NULLS LAST
            "#,
        )
        .bind(user_id)
        .fetch_all(&self.pool)
        .await
        .map_err(|e| DomainError::database(e.to_string()))?;

        Ok(rows.into_iter().map(Todo::from).collect())
    }

    async fn create(&self, todo: &Todo) -> DomainResult<Todo> {
        let row = sqlx::query_as::<_, TodoRow>(
            r#"
            INSERT INTO todos (id, user_id, farm_id, title, description, priority,
                              due_date, completed, completed_at, created_at, source)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
            RETURNING id, user_id, farm_id, title, description, priority,
                      due_date, completed, completed_at, created_at, source
            "#,
        )
        .bind(todo.id)
        .bind(todo.user_id)
        .bind(todo.farm_id)
        .bind(&todo.title)
        .bind(&todo.description)
        .bind(priority_to_string(&todo.priority))
        .bind(todo.due_date)
        .bind(todo.completed)
        .bind(todo.completed_at)
        .bind(todo.created_at)
        .bind(source_to_string(&todo.source))
        .fetch_one(&self.pool)
        .await
        .map_err(|e| DomainError::database(e.to_string()))?;

        Ok(Todo::from(row))
    }

    async fn update(&self, todo: &Todo) -> DomainResult<Todo> {
        let row = sqlx::query_as::<_, TodoRow>(
            r#"
            UPDATE todos
            SET title = $2, description = $3, priority = $4, due_date = $5,
                completed = $6, completed_at = $7
            WHERE id = $1
            RETURNING id, user_id, farm_id, title, description, priority,
                      due_date, completed, completed_at, created_at, source
            "#,
        )
        .bind(todo.id)
        .bind(&todo.title)
        .bind(&todo.description)
        .bind(priority_to_string(&todo.priority))
        .bind(todo.due_date)
        .bind(todo.completed)
        .bind(todo.completed_at)
        .fetch_one(&self.pool)
        .await
        .map_err(|e| DomainError::database(e.to_string()))?;

        Ok(Todo::from(row))
    }

    async fn mark_completed(&self, id: Uuid) -> DomainResult<()> {
        sqlx::query(
            r#"
            UPDATE todos
            SET completed = true, completed_at = NOW()
            WHERE id = $1
            "#,
        )
        .bind(id)
        .execute(&self.pool)
        .await
        .map_err(|e| DomainError::database(e.to_string()))?;

        Ok(())
    }

    async fn delete(&self, id: Uuid) -> DomainResult<()> {
        sqlx::query("DELETE FROM todos WHERE id = $1")
            .bind(id)
            .execute(&self.pool)
            .await
            .map_err(|e| DomainError::database(e.to_string()))?;

        Ok(())
    }
}
